#pragma kernel Noise
#include "Noise.compute"

RWStructuredBuffer<float> map;
float scale;
int mapSize;
int3 noiseOffset;

int octaves;
float lacunarity;
float persistence;
float weightMultiplier;

float4 params;

int indexFromCoord(uint x, uint y, uint z) {
    return z * mapSize * mapSize + y * mapSize + x;
}

float standard3DNoise(float x, float y, float z)
{
    float noise = 0;

    float frequency = scale/100;
    float amplitude = 1;
    float weight = 1;
    for (int j =0; j < octaves; j ++) {
        float n = snoise(float3(
            (x + noiseOffset.x) * scale, 
            (y + noiseOffset.y) * scale, 
            (z + noiseOffset.z) * scale
        ));
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return noise;
}

float standard2DNoise(float x, float y)
{
    float noise = 0;

    float frequency = scale/100;
    float amplitude = 1;
    float weight = 1;
    for (int j =0; j < octaves; j ++) {
        float n = snoise2D(float2(
            (x + noiseOffset.x) * scale, 
            (y + noiseOffset.z) * scale
        ));
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return noise;
}

float noiseWithHeightMap(float x, float y, float z)
{
    float ThreeDNoise = standard3DNoise(x, y, z);
    float TwoDNoise = standard2DNoise(x, z);

    if (y > TwoDNoise * mapSize) return 0.0;
    else if (y < TwoDNoise * mapSize) return ThreeDNoise;
    else return TwoDNoise;
}

[numthreads(8, 8, 8)]
void Noise (uint3 id : SV_DispatchThreadID)
{
    //float noise = standard3DNoise(id.x, id.y, id.z);
    float noise = noiseWithHeightMap(id.x, id.y, id.z);

    map[indexFromCoord(id.x, id.y, id.z)] = noise;
}


